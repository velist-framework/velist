# DOKUMEN ARSITEKTUR: Elysia-Inertia-Svelte-Kysely (EISK Stack)

## 1. Executive Summary

**Stack**: Elysia (Bun) + Inertia.js 2 + Svelte 5 + Kysely/Drizzle + Bun:SQLite  
**Paradigma**: Vertical Feature Slicing + Type-Safe Fullstack  
**ID System**: UUID v7 (time-ordered, unguessable)  
**Target**: Solo developer/small team, rapid development, type safety maksimal, migrasi dari Laravel.

## 2. Fundamental Principles

1. **Vertical Slicing**: 1 folder feature = API + UI + Database + Types
2. **Type Safety Chain**: Database Schema ‚Üí TypeBox ‚Üí Svelte Props (no manual typing)
3. **Co-location**: Backend dan frontend logic dalam 1 folder fitur
4. **No Horizontal Layers**: Tidak ada folder `controllers/`, `models/`, `components/` global
5. **Bun-Native**: Gunakan built-in Bun APIs (SQLite, crypto, password hashing)
6. **UUID v7**: Semua ID menggunakan UUID v7 (time-ordered, lebih baik dari auto-increment dan UUID v4)

## 3. Project Structure

```
project-root/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ features/                    # VERTICAL SLICES
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _core/                   # Core infrastructure (auth, db, etc)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts           # Elysia routes & middleware
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service.ts       # Business logic
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository.ts    # Kysely database access
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schema.ts        # TypeBox + DB types
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/           # Inertia pages (Svelte)
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Login.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Register.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ components/      # Shared within feature
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ AuthCard.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ connection.ts    # Kysely instance
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ migrations/      # Drizzle SQL migrations
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ 0000_*.sql   # Auto-generated by Drizzle
‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ runner.ts    # Drizzle migration runner
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ schema.ts        # Drizzle schema definition
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ seeder.ts        # Database seeder
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dashboard/               # Another feature example
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ api.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ service.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ repository.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ schema.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ Index.svelte
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ shared/                      # Cross-cutting (hanya jika truly shared)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/                      # UI primitives (Button, Input)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layouts/                 # Inertia layouts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PublicLayout.svelte
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AppLayout.svelte
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lib/                     # Utils, helpers, types
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ uuid.ts              # UUID v7 generator
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ inertia/                     # Inertia bootstrap
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plugin.ts                # Custom Inertia plugin for Elysia
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.ts                   # Client-side resolver & mount
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ssr.ts                   # SSR handler (optional)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ types/                       # Global type declarations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ elysia.d.ts              # Elysia context extensions
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ bootstrap.ts                 # App composition root
‚îÇ
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îú‚îÄ‚îÄ dev.sqlite                   # SQLite file (gitignored)
‚îÇ   ‚îî‚îÄ‚îÄ schema.sql                   # Backup schema
‚îÇ
‚îú‚îÄ‚îÄ static/                          # Public assets
‚îú‚îÄ‚îÄ tests/                           # Feature-based tests
‚îú‚îÄ‚îÄ drizzle.config.ts                # Drizzle configuration
‚îú‚îÄ‚îÄ bunfig.toml                      # Bun configuration
‚îú‚îÄ‚îÄ vite.config.ts                   # Vite + Svelte + Inertia
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

## 4. Layer Specifications

### 4.1 Database Strategy: Hybrid Approach (Drizzle + Kysely)

**Stack**: Drizzle Kit (schema & migrations) + Kysely (runtime queries) + Bun:SQLite

#### Why Hybrid?

| Concern | Tool | Reason |
|---------|------|--------|
| **Schema Definition** | Drizzle Kit | Type-safe schema as code, auto-generate SQL migrations |
| **Migrations** | Drizzle ORM | Native `bun:sqlite` support, reliable migration runner |
| **Runtime Queries** | Kysely | More flexible SQL builder, better query composability, familiar API |

#### Workflow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Drizzle Schema ‚îÇ ‚îÄ‚îÄ‚ñ∫ ‚îÇ  SQL Migration   ‚îÇ ‚îÄ‚îÄ‚ñ∫ ‚îÇ  SQLite DB      ‚îÇ
‚îÇ  (schema.ts)    ‚îÇ     ‚îÇ  (0000_*.sql)    ‚îÇ     ‚îÇ  (dev.sqlite)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                        ‚îÇ
                                                        ‚ñº
                                               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                               ‚îÇ  Kysely Queries ‚îÇ
                                               ‚îÇ  (repository.ts)‚îÇ
                                               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

1. **Define Schema** ‚Üí Edit `schema.ts` with Drizzle's table API
2. **Generate Migration** ‚Üí `bun run db:generate` ‚Üí creates SQL file
3. **Apply Migration** ‚Üí `bun run db:migrate` ‚Üí Drizzle migrator applies to SQLite
4. **Query in App** ‚Üí Use Kysely's query builder in repositories

#### Critical: Keep Them in Sync

When adding new tables/columns to Drizzle schema, update `DatabaseSchema` interface in `connection.ts`:

```typescript
// In schema.ts (Drizzle)
export const posts = sqliteTable('posts', {
  id: text('id').primaryKey(),
  title: text('title').notNull(),
});

// In connection.ts (Kysely types)
export interface DatabaseSchema {
  posts: {
    id: string
    title: string
  }
  // ... existing tables
}
```

#### Migration Commands

```bash
# Generate SQL from schema changes
bun run db:generate

# Apply pending migrations
bun run db:migrate

# Seed with test data
bun run db:seed
```

---

### 4.2 UUID v7 Library

**File**: `src/shared/lib/uuid.ts`

UUID v7 dipilih karena:
- **Time-ordered**: Data terurut berdasarkan waktu (tidak fragmented seperti UUID v4)
- **Unpredictable**: Tidak sequential seperti auto-increment (lebih aman)
- **Built-in timestamp**: Bisa extract creation time tanpa query DB

```typescript
/**
 * UUID v7 Generator
 * Format: xxxxxxxx-xxxx-7xxx-yxxx-xxxxxxxxxxxx
 * - 48 bits: Unix timestamp (milliseconds)
 * - 4 bits: Version (0111 = 7)
 * - 12 bits: rand_a (random)
 * - 2 bits: Variant (10)
 * - 62 bits: rand_b (random)
 */

export function uuidv7(): string {
  const timestamp = Date.now()
  const bytes = new Uint8Array(16)
  
  // Write timestamp (48 bits = 6 bytes) big-endian
  bytes[0] = (timestamp >> 40) & 0xff
  bytes[1] = (timestamp >> 32) & 0xff
  bytes[2] = (timestamp >> 24) & 0xff
  bytes[3] = (timestamp >> 16) & 0xff
  bytes[4] = (timestamp >> 8) & 0xff
  bytes[5] = timestamp & 0xff
  
  // Fill with random values
  const randomBytes = crypto.getRandomValues(new Uint8Array(10))
  for (let i = 0; i < 10; i++) {
    bytes[6 + i] = randomBytes[i]
  }
  
  // Set version = 7 (0111)
  bytes[6] = (bytes[6] & 0x0f) | 0x70
  // Set variant = 10 (RFC 4122)
  bytes[8] = (bytes[8] & 0x3f) | 0x80
  
  const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0'))
  return `${hex.slice(0, 4).join('')}-${hex.slice(4, 6).join('')}-${hex.slice(6, 8).join('')}-${hex.slice(8, 10).join('')}-${hex.slice(10).join('')}`
}

export function isValidUuidv7(uuid: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid)
}

export function getTimestampFromUuidv7(uuid: string): Date | null {
  if (!isValidUuidv7(uuid)) return null
  const hex = uuid.replace(/-/g, '').slice(0, 12)
  return new Date(parseInt(hex, 16))
}
```

### 4.3 Database Layer (Kysely + Bun:SQLite)

**File**: `src/features/_core/database/connection.ts`

Semua ID menggunakan UUID v7 (string). Hanya migrations table internal yang tetap auto-increment.

```typescript
import { Kysely, SqliteDialect, type Generated, type Insertable, type Selectable, type Updateable } from 'kysely'
import { Database } from 'bun:sqlite'

// SINGLE SOURCE OF TRUTH - Database Schema
// Semua ID menggunakan UUID v7 (string)
export interface DatabaseSchema {
  users: {
    id: string  // UUID v7
    email: string
    password_hash: string
    name: string
    role: string              // 'user' | 'admin'
    email_verified_at: string | null
    created_at: string
    updated_at: string
  }
  
  sessions: {
    id: string       // UUID v7
    user_id: string  // FK ke users.id (UUID v7)
    ip_address: string | null
    user_agent: string | null
    payload: string
    last_activity: number
  }
  
  password_reset_tokens: {
    email: string
    token: string  // UUID v7
    created_at: string | null
  }
  
  migrations: {
    id: Generated<number>  // Internal use, tetap auto-increment
    name: string
    executed_at: string
  }
}

// Helper types - export untuk digunakan di seluruh app
export type User = Selectable<DatabaseSchema['users']>
export type NewUser = Insertable<DatabaseSchema['users']>
export type UserUpdate = Updateable<DatabaseSchema['users']>

// Transaction type untuk repository
export type Transaction = Kysely<DatabaseSchema>

// Ensure db directory exists
await Bun.write('./db/.keep', '')

// Create single SQLite connection with WAL mode enabled
const sqliteDb = new Database('./db/dev.sqlite', { create: true, readwrite: true })
sqliteDb.exec('PRAGMA journal_mode = WAL;')
sqliteDb.exec('PRAGMA foreign_keys = ON;')

// Singleton instance - use the same connection
export const db = new Kysely<DatabaseSchema>({
  dialect: new SqliteDialect({
    database: sqliteDb as any
  }),
  log(event) {
    if (event.level === 'query' && process.env.NODE_ENV === 'development') {
      console.log(`\x1b[36m[SQL]\x1b[0m ${event.query.sql}`)
    }
  }
})
```

### 4.4 Drizzle Schema (for Migrations)

**File**: `src/features/_core/database/schema.ts`

Drizzle digunakan untuk migrations karena lebih kompatibel dengan `bun:sqlite`.

```typescript
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { sql } from 'drizzle-orm';

export const users = sqliteTable('users', {
  id: text('id').primaryKey(), // UUID v7
  email: text('email').notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  name: text('name').notNull(),
  role: text('role').notNull().default('user'),
  emailVerifiedAt: text('email_verified_at'),
  createdAt: text('created_at').notNull().default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').notNull().default(sql`CURRENT_TIMESTAMP`),
});

export const sessions = sqliteTable('sessions', {
  id: text('id').primaryKey(), // UUID v7
  userId: text('user_id').notNull().references(() => users.id),
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),
  payload: text('payload').notNull(),
  lastActivity: integer('last_activity').notNull(),
});

export const passwordResetTokens = sqliteTable('password_reset_tokens', {
  email: text('email').primaryKey(),
  token: text('token').notNull(),
  createdAt: text('created_at'),
});
```

### 4.5 Repository Pattern

**File**: `src/features/_core/auth/repository.ts`

Repository meng-generate UUID v7 saat create. Semua ID parameter menggunakan string.

```typescript
import { db, type DatabaseSchema, type Transaction, type User, type NewUser } from '../database/connection'
import { uuidv7 } from '../../../shared/lib/uuid'

export class AuthRepository {
  constructor(private trx?: Transaction) {}
  
  private get db() {
    return this.trx ?? db
  }

  // UUID v7 string parameter
  async findById(id: string): Promise<User | undefined> {
    return this.db
      .selectFrom('users')
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst()
  }

  async findByEmail(email: string): Promise<User | undefined> {
    return this.db
      .selectFrom('users')
      .where('email', '=', email)
      .selectAll()
      .executeTakeFirst()
  }

  // Auto-generate UUID v7
  async create(data: NewUser): Promise<User> {
    const id = uuidv7()
    const { id: _, ...rest } = data as NewUser & { id?: string }
    return this.db
      .insertInto('users')
      .values({
        id,
        ...rest,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      } as NewUser)
      .returningAll()
      .executeTakeFirstOrThrow()
  }

  async updatePassword(userId: string, hash: string): Promise<void> {
    await this.db
      .updateTable('users')
      .set({ 
        password_hash: hash,
        updated_at: new Date().toISOString()
      })
      .where('id', '=', userId)
      .execute()
  }

  async deleteSession(token: string): Promise<void> {
    await this.db
      .deleteFrom('sessions')
      .where('id', '=', token)
      .execute()
  }

  // Static method untuk transactions
  static async transaction<T>(callback: (repo: AuthRepository) => Promise<T>): Promise<T> {
    return db.transaction().execute(async (trx) => {
      const repo = new AuthRepository(trx)
      return callback(repo)
    })
  }
}
```

### 4.6 Service Layer (Business Logic)

**File**: `src/features/_core/auth/service.ts`

Gunakan `Bun.password.hash()` dan `Bun.password.verify()` (bukan `hash.bcrypt()` yang deprecated).

```typescript
import { AuthRepository } from './repository'
import type { NewUser } from '../database/connection'
import { t, type Static } from 'elysia'

// TypeBox Schemas - digunakan untuk validation & type inference
export const LoginSchema = t.Object({
  email: t.String({ format: 'email', maxLength: 255 }),
  password: t.String({ minLength: 8, maxLength: 255 }),
  remember: t.Optional(t.Boolean({ default: false }))
})

export const RegisterSchema = t.Object({
  email: t.String({ format: 'email', maxLength: 255 }),
  password: t.String({ minLength: 8, maxLength: 255 }),
  password_confirmation: t.String({ minLength: 8 }),
  name: t.String({ minLength: 2, maxLength: 100 })
}, {
  additionalProperties: false
})

export type LoginPayload = Static<typeof LoginSchema>
export type RegisterPayload = Static<typeof RegisterSchema>

// Safe user type (without password)
export type SafeUser = Omit<NewUser, 'password_hash'> & { id: string }

export class AuthService {
  constructor(private repo: AuthRepository = new AuthRepository()) {}

  async register(payload: RegisterPayload): Promise<SafeUser> {
    // Validasi password match
    if (payload.password !== payload.password_confirmation) {
      throw new Error('Password confirmation does not match')
    }

    // Check existing
    const existing = await this.repo.findByEmail(payload.email)
    if (existing) {
      throw new Error('Email already registered')
    }

    // Hash password using Bun (modern API)
    const passwordHash = await Bun.password.hash(payload.password, {
      algorithm: 'bcrypt',
      cost: 10
    })

    // Create user dengan explicit timestamps
    const user = await this.repo.create({
      email: payload.email,
      name: payload.name,
      password_hash: passwordHash,
      email_verified_at: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    } as unknown as NewUser)

    // Return safe user (exclude password)
    const { password_hash, ...safeUser } = user
    return safeUser as SafeUser
  }

  async attempt(email: string, password: string): Promise<SafeUser> {
    const user = await this.repo.findByEmail(email)
    if (!user) {
      throw new Error('Invalid credentials')
    }

    const valid = await Bun.password.verify(password, user.password_hash)
    if (!valid) {
      throw new Error('Invalid credentials')
    }

    const { password_hash, ...safeUser } = user
    return safeUser as SafeUser
  }

  async logout(token: string): Promise<void> {
    await this.repo.deleteSession(token)
  }
}
```

### 4.7 Custom Inertia Plugin

**File**: `src/inertia/plugin.ts`

`@elysiajs/inertia` tidak tersedia di npm, jadi kita buat custom plugin.

```typescript
import { Elysia } from 'elysia'

interface InertiaPage {
  component: string
  props: Record<string, unknown>
  url: string
  version: string
}

interface InertiaConfig {
  version?: string
  rootTemplate?: (page: InertiaPage) => string
}

// Default HTML template for Inertia
const defaultTemplate = (page: InertiaPage) => `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inertia App</title>
</head>
<body>
  <div id="app" data-page="${escapeHtml(JSON.stringify(page))}"></div>
  <script type="module" src="/src/inertia/app.ts"></script>
</body>
</html>`

function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;')
}

export interface Inertia {
  render: (component: string, props?: Record<string, unknown>) => Response
  redirect: (url: string) => Response
  location: (url: string) => Response
}

function createInertia(request: Request, config: InertiaConfig = {}): Inertia {
  const version = config.version || process.env.APP_VERSION || '1.0.0'
  
  return {
    render(component: string, props: Record<string, unknown> = {}) {
      const url = new URL(request.url).pathname + new URL(request.url).search
      const page: InertiaPage = { component, props, url, version }

      const isInertia = request.headers.get('X-Inertia') === 'true'
      
      if (isInertia) {
        return new Response(JSON.stringify(page), {
          headers: {
            'Content-Type': 'application/json',
            'X-Inertia': 'true',
            'Vary': 'Accept'
          }
        })
      }

      const html = config.rootTemplate ? config.rootTemplate(page) : defaultTemplate(page)
      return new Response(html, { headers: { 'Content-Type': 'text/html' } })
    },
    
    redirect(url: string) {
      return new Response(null, { status: 302, headers: { Location: url } })
    },
    
    location(url: string) {
      return new Response(null, {
        status: 409,
        headers: { 'X-Inertia-Location': url, 'X-Inertia': 'true' }
      })
    }
  }
}

export function inertia(config: InertiaConfig = {}) {
  return new Elysia({ name: 'inertia' })
    .derive((ctx) => ({ inertia: createInertia(ctx.request, config) }))
}
```

### 4.8 API Layer (Elysia)

**File**: `src/features/_core/auth/api.ts`

Gunakan type assertion untuk mengakses `inertia` dari context karena module augmentation complex di Elysia v1.4.

```typescript
import { Elysia } from 'elysia'
import { AuthService, LoginSchema, RegisterSchema } from './service'
import { AuthRepository } from './repository'
import { cookie } from '@elysiajs/cookie'
import { jwt } from '@elysiajs/jwt'
import type { Inertia } from '../../../inertia/plugin'

// Extend Elysia context
declare module 'elysia' {
  interface ElysiaInstance {
    inertia: Inertia
    user: {
      id: string  // UUID v7
      email: string
      name: string
    } | null
  }
}

export const authApi = new Elysia({ prefix: '/auth' })
  .use(cookie())
  .use(jwt({
    secret: process.env.JWT_SECRET || 'your-secret-key',
    exp: '7d'
  }))
  
  // Dependency injection ke context
  .derive(() => ({
    authService: new AuthService(),
    authRepo: new AuthRepository()
  }))

  // GET /auth/login - Show login page
  .get('/login', (ctx) => {
    const { inertia } = ctx as typeof ctx & { inertia: Inertia }
    return inertia.render('auth/Login', { errors: {}, status: null })
  })

  // POST /auth/login - Handle login
  .post('/login', async (ctx) => {
    const { body, authService, jwt, cookie, inertia } = ctx as typeof ctx & { inertia: Inertia }
    try {
      const user = await authService.attempt(body.email, body.password)
      
      // Create token dengan UUID sub
      const token = await jwt.sign({ 
        sub: user.id,  // UUID v7
        email: user.email,
        name: user.name
      })

      cookie.auth.set({
        value: token,
        httpOnly: true,
        maxAge: body.remember ? 86400 * 30 : 86400,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/'
      })

      return inertia.redirect('/dashboard')
    } catch (error) {
      return inertia.render('auth/Login', {
        errors: { email: error instanceof Error ? error.message : 'Login failed' },
        status: null
      })
    }
  }, { body: LoginSchema })

  // GET /auth/register
  .get('/register', (ctx) => {
    const { inertia } = ctx as typeof ctx & { inertia: Inertia }
    return inertia.render('auth/Register', { errors: {} })
  })

  // POST /auth/register
  .post('/register', async (ctx) => {
    const { body, authService, inertia } = ctx as typeof ctx & { inertia: Inertia }
    try {
      await authService.register(body)
      return inertia.render('auth/Login', {
        status: 'Registration successful. Please login.'
      })
    } catch (error) {
      return inertia.render('auth/Register', {
        errors: { email: error instanceof Error ? error.message : 'Registration failed' }
      })
    }
  }, { body: RegisterSchema })

  // POST /auth/logout
  .post('/logout', async (ctx) => {
    const { cookie, jwt, authRepo, inertia } = ctx as typeof ctx & { inertia: Inertia }
    const token = (cookie.auth as { value?: string }).value
    if (token) {
      try {
        await jwt.verify(token)
        await authRepo.deleteSession(token)
      } catch { /* Ignore invalid token */ }
    }
    ;(cookie.auth as { remove: () => void }).remove()
    return inertia.redirect('/auth/login')
  })

  // Middleware: Attach user to context
  .derive(async (ctx) => {
    const { cookie, jwt } = ctx
    const token = (cookie.auth as { value?: string }).value
    if (!token) return { user: null }
    
    try {
      const payload = await jwt.verify(token)
      return { user: payload as unknown as { id: string; email: string; name: string } }
    } catch {
      return { user: null }
    }
  })

  // Macro untuk protected routes
  .macro(({ onBeforeHandle }) => ({
    auth(required: boolean) {
      if (!required) return
      onBeforeHandle((ctx: any) => {
        const { user, inertia } = ctx
        if (!user) return inertia.redirect('/auth/login')
      })
    }
  }))
```

### 4.9 Frontend Layer (Svelte 5 + Inertia)

**File**: `src/inertia/app.ts`

```typescript
import { createInertiaApp, type ResolvedComponent } from '@inertiajs/svelte';
import { mount, hydrate } from 'svelte';
import type { Component } from 'svelte';

// Type augmentation for Vite's import.meta.glob
declare global {
  interface ImportMeta {
    glob: <T>(pattern: string, options?: { eager?: boolean }) => Record<string, () => Promise<T>>
  }
}

createInertiaApp({
  id: 'app',
  
  resolve: async (name) => {
    const [feature, page] = name.split('/')
    const pages = import.meta.glob<{ default: Component; layout?: Component }>(
      '../features/**/pages/**/*.svelte', 
      { eager: false }
    )
    const path = `../features/${feature}/pages/${page.charAt(0).toUpperCase() + page.slice(1)}.svelte`
    
    const module = await pages[path]()
    return {
      default: module.default as unknown as ResolvedComponent['default'],
      layout: module.layout as any
    }
  },
  
  setup({ el, App, props }) {
    if (!el) throw new Error('Root element not found')
    if (el.dataset.serverRendered === 'true') {
      hydrate(App, { target: el, props })
    } else {
      mount(App, { target: el, props })
    }
  },
  
  progress: { color: '#4f46e5', showSpinner: true }
})
```

## 5. Main Application Bootstrap

**File**: `src/bootstrap.ts`

```typescript
import { Elysia } from 'elysia'
import { staticPlugin } from '@elysiajs/static'
import { cors } from '@elysiajs/cors'
import { helmet } from 'elysia-helmet'
import { inertia, type Inertia } from './inertia/plugin'
import { authApi } from './features/_core/auth/api'
import { dashboardApi } from './features/dashboard/api'
import { runMigrations } from './features/_core/database/migrations/runner'

// Run migrations on startup (dev only)
if (process.env.NODE_ENV !== 'production') {
  await runMigrations()
}

const app = new Elysia()
  .use(helmet())
  .use(cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:5173',
    credentials: true
  }))
  .use(staticPlugin({ assets: './static', prefix: '/' }))
  .use(inertia())
  
  // Health check
  .get('/health', () => ({ 
    status: 'ok', 
    timestamp: new Date().toISOString() 
  }))
  
  // Mount features
  .use(authApi)
  .use(dashboardApi)
  
  // Root redirect
  .get('/', (ctx) => {
    const { inertia } = ctx as typeof ctx & { inertia: Inertia }
    return inertia.redirect('/dashboard')
  })
  
  // Catch-all untuk SPA fallback (Inertia)
  .get('*', (ctx) => {
    const { inertia, request } = ctx as typeof ctx & { inertia: Inertia }
    return inertia.render('errors/404', { path: request.url })
  })

// Start server
const PORT = process.env.PORT || 3000
app.listen(PORT, () => {
  console.log(`ü¶ä Elysia is running at http://localhost:${PORT}`)
  console.log(`üì¶ Environment: ${process.env.NODE_ENV || 'development'}`)
})

export type App = typeof app
```

## 6. Configuration Files

**File**: `drizzle.config.ts`

```typescript
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'sqlite',
  schema: './src/features/_core/database/schema.ts',
  out: './src/features/_core/database/migrations',
  dbCredentials: {
    url: './db/dev.sqlite',
  },
});
```

**File**: `vite.config.ts`

```typescript
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'
import path from 'path'

export default defineConfig({
  plugins: [
    svelte({
      compilerOptions: {
        hydratable: true,
        generate: 'hydratable'
      }
    })
  ],
  
  resolve: {
    alias: {
      $features: path.resolve(__dirname, './src/features'),
      $shared: path.resolve(__dirname, './src/shared'),
      $inertia: path.resolve(__dirname, './src/inertia')
    }
  },
  
  server: {
    port: 5173,
    strictPort: true,
    proxy: {
      '/auth': 'http://localhost:3000',
      '/api': 'http://localhost:3000',
      '/dashboard': 'http://localhost:3000'
    }
  },
  
  build: {
    manifest: true,
    outDir: 'dist',
    rollupOptions: {
      input: './src/inertia/app.ts'
    }
  }
})
```

**File**: `tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "baseUrl": ".",
    "paths": {
      "$features/*": ["src/features/*"],
      "$shared/*": ["src/shared/*"],
      "$inertia/*": ["src/inertia/*"]
    },
    "typeRoots": ["./node_modules/@types", "./src/types"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**File**: `package.json`

```json
{
  "name": "eisk-app",
  "type": "module",
  "scripts": {
    "dev": "concurrently \"bun run dev:server\" \"bun run dev:client\"",
    "dev:server": "bun --watch src/bootstrap.ts",
    "dev:client": "vite",
    "build": "vite build",
    "db:migrate": "bun src/features/_core/database/migrations/runner.ts",
    "db:generate": "drizzle-kit generate",
    "db:seed": "bun src/features/_core/database/seeder.ts",
    "lint": "eslint src --ext .ts,.svelte",
    "typecheck": "tsc --noEmit && svelte-check --tsconfig ./tsconfig.json"
  },
  "dependencies": {
    "elysia": "latest",
    "@elysiajs/cookie": "latest",
    "@elysiajs/cors": "latest",
    "@elysiajs/jwt": "latest",
    "@elysiajs/static": "latest",
    "@inertiajs/svelte": "^2.0.0",
    "drizzle-orm": "^0.45.0",
    "kysely": "^0.27.0",
    "elysia-helmet": "latest"
  },
  "devDependencies": {
    "@sveltejs/vite-plugin-svelte": "^6.0.0",
    "@types/bun": "latest",
    "bun-types": "latest",
    "concurrently": "^8.2.0",
    "drizzle-kit": "^0.31.0",
    "svelte": "^5.0.0",
    "svelte-check": "^3.6.0",
    "typescript": "^5.3.0",
    "vite": "^6.0.0"
  }
}
```

## 7. Migration & Seeder

**File**: `src/features/_core/database/migrations/runner.ts`

```typescript
import { drizzle } from 'drizzle-orm/bun-sqlite';
import { Database } from 'bun:sqlite';
import { migrate } from 'drizzle-orm/bun-sqlite/migrator';
import { join } from 'node:path';

export async function runMigrations() {
  try {
    console.log('üîÑ Running migrations...');
    
    const sqlite = new Database('./db/dev.sqlite', { create: true });
    const db = drizzle(sqlite);
    
    await migrate(db, {
      migrationsFolder: join(process.cwd(), 'src/features/_core/database/migrations'),
    });
    
    console.log('‚úÖ Migrations completed');
    
    sqlite.close();
  } catch (error) {
    console.error('‚ùå Migration failed:', error);
    throw error;
  }
}

// Run if called directly
if (import.meta.main) {
  await runMigrations();
  process.exit(0);
}
```

**File**: `src/features/_core/database/seeder.ts`

```typescript
import { drizzle } from 'drizzle-orm/bun-sqlite';
import { Database } from 'bun:sqlite';
import { users } from './schema';
import { uuidv7 } from '../../../shared/lib/uuid';
import { eq } from 'drizzle-orm';

async function seed() {
  console.log('üå± Seeding database...');

  const sqlite = new Database('./db/dev.sqlite');
  const db = drizzle(sqlite);

  // Check if admin exists
  const existing = await db
    .select()
    .from(users)
    .where(eq(users.email, 'admin@example.com'))
    .get();

  if (existing) {
    console.log('  ‚úì Admin user already exists');
  } else {
    // Create admin user
    const passwordHash = await Bun.password.hash('password123', {
      algorithm: 'bcrypt',
      cost: 10,
    });

    await db.insert(users).values({
      id: uuidv7(),
      email: 'admin@example.com',
      name: 'Administrator',
      role: 'admin',
      passwordHash: passwordHash,
      emailVerifiedAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    });

    console.log('  ‚úì Admin user created (admin@example.com / password123)');
  }

  console.log('‚úÖ Seeding completed');
  sqlite.close();
  process.exit(0);
}

seed().catch((error) => {
  console.error('‚ùå Seeding failed:', error);
  process.exit(1);
});
```

### Workflow Migrations

1. **Generate migrations dari schema:**
   ```bash
   bun run db:generate
   ```

2. **Jalankan migrations:**
   ```bash
   bun run db:migrate
   ```

3. **Seed database:**
   ```bash
   bun run db:seed
   ```

## 8. Migration Strategy (dari Laravel)

| Laravel Concept | EISK Equivalent | Notes |
|----------------|-----------------|-------|
| `php artisan migrate` | `bun run db:migrate` | Drizzle migrations, menggunakan bun:sqlite |
| `php artisan db:seed` | `bun run db:seed` | UUID v7 untuk semua ID |
| `Auth::attempt()` | `authService.attempt()` | Explicit service injection |
| `Request $request` | `{ body }` | Destructured + validated by TypeBox |
| `return redirect()` | `inertia.redirect()` | Same mental model |
| `Session` | Bun:SQLite + JWT cookie | Stateless, scalable |
| `Blade @csrf` | Cookie-based | Handled automatically |
| `resources/js/Pages/` | `src/features/X/pages/` | Co-located with backend |
| Auto-increment ID | UUID v7 | Time-ordered, unguessable |

## 9. Key Differences from Original ARCHITECTURE.md

### Package Changes
- **Removed**: `@elysiajs/inertia` (tidak tersedia di npm)
- **Added**: 
  - `@elysiajs/cors` untuk CORS support
  - `drizzle-orm` & `drizzle-kit` untuk migrations
- **Updated**: 
  - `@inertiajs/svelte`: ^1.0.0 ‚Üí ^2.0.0
  - `@sveltejs/vite-plugin-svelte`: ^3.0.0 ‚Üí ^6.0.0
  - `vite`: ^5.0.0 ‚Üí ^6.0.0

### Custom Implementations
1. **Inertia Plugin**: Custom implementation di `src/inertia/plugin.ts`
2. **UUID v7**: Custom generator di `src/shared/lib/uuid.ts`

### Database Changes
- **ID System**: Semua ID dari `number` (auto-increment) menjadi `string` (UUID v7)
- **Role Field**: Ditambahkan `role` column di users table
- **Password Hashing**: Gunakan `Bun.password.hash()` bukan `hash.bcrypt()`
- **Migrations**: Gunakan Drizzle ORM untuk migrations (lebih kompatibel dengan bun:sqlite)
- **Query**: Gunakan Kysely untuk query (tetap type-safe)

### Type Handling
- Gunakan type assertion `(ctx as typeof ctx & { inertia: Inertia })` untuk akses context
- JWT payload `sub: user.id` - UUID string

## 10. Development Workflow

1. **Create Feature**:
   ```bash
   mkdir src/features/invoices
   touch src/features/invoices/{api.ts,service.ts,repository.ts,schema.ts}
   mkdir -p src/features/invoices/pages
   ```

2. **Update Drizzle Schema** (jika perlu tabel baru):
   - Edit `src/features/_core/database/schema.ts`
   - Run `bun run db:generate` untuk generate SQL migration
   - Run `bun run db:migrate` untuk apply migration

3. **Build API**:
   - Implement repository methods dengan UUID v7 generation
   - Write service logic
   - Create Elysia routes dengan `.use()`

4. **Build UI**:
   - Create Svelte page in `pages/`
   - Use `useForm()` for mutations
   - Access props dari backend

5. **Connect**:
   - Import API plugin di `bootstrap.ts`
   - Navigate via `<a use:inertia>`

## 11. Deployment Checklist

- [ ] Set `NODE_ENV=production`
- [ ] Change JWT secret
- [ ] Enable secure cookies
- [ ] Run `vite build` untuk assets
- [ ] Copy `db/dev.sqlite` atau setup production SQLite/PostgreSQL
- [ ] Use process manager (PM2/systemd) untuk Bun
- [ ] Setup reverse proxy (Nginx/Caddy) dengan SSL
- [ ] Reset database untuk apply UUID v7 migrations

---

**Status**: ‚úÖ Dokumen updated dengan perubahan terbaru:
- UUID v7 untuk semua ID
- Custom Inertia plugin
- Drizzle untuk migrations
- Kysely untuk queries
- Package versions terbaru
- Role-based user system
